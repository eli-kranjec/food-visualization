import { Attribute } from './attribute';
import { Mark, MarkAttributes } from './mark';
import { TimeProvider } from './utils';
export type ScalesOptions = {
    animationDuration?: number;
    padding?: number | {
        top?: number;
        left?: number;
        right?: number;
        bottom?: number;
    };
    minScale?: number;
    maxScale?: number;
};
export type TransformInfo = {
    k?: number;
    kx?: number;
    ky?: number;
    x?: number;
    y?: number;
};
export type OutputTransformInfo = Required<TransformInfo>;
export type LinearScale = ((domainVal: number) => number) & {
    domain: () => [number, number];
    range: () => [number, number];
    invert(rangeVal: number): number;
};
/**
 * A class that manages a linked x and y scale.
 */
export declare class Scales {
    animationDuration: number;
    squareAspect: boolean;
    _xDomain: [Attribute<number>, Attribute<number>];
    _yDomain: [Attribute<number>, Attribute<number>];
    _xRange: [Attribute<number>, Attribute<number>];
    _yRange: [Attribute<number>, Attribute<number>];
    minScale: number;
    maxScale: number;
    private _xScaleFactor;
    private _yScaleFactor;
    private _translateX;
    private _translateY;
    xScale: LinearScale;
    yScale: LinearScale;
    private _calculatingTransform;
    timeProvider: TimeProvider;
    controller: ScalesController | null;
    private _updatedNoAdvance;
    private listeners;
    constructor(opts?: ScalesOptions);
    configure(opts?: ScalesOptions): Scales;
    xDomain(extent: [number, number]): Scales;
    xDomain(extent: [number, number], animated: boolean): Scales;
    xDomain(): [number, number];
    yDomain(extent: [number, number]): Scales;
    yDomain(extent: [number, number], animated: boolean): Scales;
    yDomain(): [number, number];
    xRange(extent: [number, number]): Scales;
    xRange(extent: [number, number], animated: boolean): Scales;
    xRange(): [number, number];
    yRange(extent: [number, number]): Scales;
    yRange(extent: [number, number], animated: boolean): Scales;
    yRange(): [number, number];
    xDSpan(): number;
    yDSpan(): number;
    xRSpan(): number;
    yRSpan(): number;
    /**
     * Changes the domains of the scales so that the aspect ratio is square.
     *
     * @returns this Scales instance
     */
    makeSquareAspect(): Scales;
    onUpdate(fn: (scales: Scales) => void): Scales;
    isNeutral(): boolean;
    advance(dt?: number | undefined): boolean;
    scaleBy(ds: number | [number, number], centerPoint?: [number, number] | null): Scales;
    translateBy(dx: number, dy: number): Scales;
    transform(): OutputTransformInfo;
    transform(scaleInfo: TransformInfo): Scales;
    transform(scaleInfo: TransformInfo, animated: boolean): Scales;
    /**
     * Resets the zoom transform to the identity transform.
     * @param animated Whether to animate the change
     * @returns this `Scales` instance
     */
    reset(animated?: boolean): Scales;
    /**
     * Animates or changes the scale and translate factors to change to the
     * viewport specified by the given controller. The controller is not followed
     * or saved after the initial transformation.
     *
     * @param controller An object specifying the new zoom transform through the
     *    `transform()` method
     * @param animated Whether to animate the transition (default `true`)
     *
     * @returns this `Scales` instance
     */
    zoomTo(controller: ScalesController, animated?: boolean): Scales;
    _calculateControllerTransform(): TransformInfo;
    /**
     * Causes the scales to automatically update whenever the given scales
     * controller returns a different transform.
     *
     * @param controller An object specifying the correct zoom transform at any
     *    given time
     * @param animated Whether to animate the initial zoom to the controller's
     *    value.
     */
    follow(controller: ScalesController, animated?: boolean): Scales;
    /**
     * Removes the controller that the scales are currently following.
     *
     * @returns this `Scales` instance
     */
    unfollow(): Scales;
    /**
     * Waits until all animations on the scales have finished, then resolves the
     * promise.
     */
    wait(rejectOnCancel?: boolean): Promise<any>;
}
export interface ScalesController {
    transform(scales: Scales): TransformInfo;
}
/**
 * A class that directs a `Scales` instance to follow positional coordinates
 * for a set of marks. Centering a single mark and/or following a set of marks
 * are supported.
 *
 * It is important to make sure that the `Scales` instance has its domain and
 * range correctly set according to the data and the viewport, respectively,
 * for the zooming calculations to work.
 */
export declare class MarkFollower<AttributeSet extends MarkAttributes> implements ScalesController {
    marks: Mark<AttributeSet>[];
    centerMark: Mark<AttributeSet> | undefined;
    xAttr: keyof AttributeSet;
    yAttr: keyof AttributeSet;
    padding: number;
    transformCoordinates: boolean;
    inverseTransformCoordinates: boolean;
    lastCompute: {
        time: number;
        scales: Scales;
        result: TransformInfo;
    } | undefined;
    /**
     * @param marks An array of marks to follow.
     * @param opts Options for the zoom calculation:
     *  - `centerMark`: The mark to place at the center of the viewport
     *  - `xAttr`: The attribute name that defines the x coordinate of each mark
     *    (default `x`). If `transformCoordinates` is `false`, the un-transformed
     *    value of the attribute will be taken.
     *  - `yAttr`: The attribute name that defines the y coordinate of each mark
     *    (default `y`) If `transformCoordinates` is `false`, the un-transformed
     *    value of the attribute will be taken.
     *  - `padding`: The amount of padding around the box bounding the given marks
     *    to include in the zoom transform.
     *  - `transformCoordinates`: Whether or not to transform the coordinates using
     *    the x/y attributes' transform functions. Typically if using the Scales
     *    to perform the transformation, you will want to keep this value at its
     *    default of `false`. Running the transform function while computing the
     *    scale transforms can lead to infinite recursions. Only set this to true
     *    if you are using the `Scales` outside of the main `Attribute` value
     *    calculation and transformation pipeline.
     */
    constructor(marks: Mark<AttributeSet>[], opts?: {
        centerMark?: Mark<AttributeSet>;
        xAttr?: keyof AttributeSet;
        yAttr?: keyof AttributeSet;
        padding?: number;
        transformCoordinates?: boolean;
        inverseTransformCoordinates?: boolean;
    });
    transform(scales: Scales): TransformInfo;
    _getMarkLocation(scales: Scales, mark: Mark<AttributeSet>): {
        x: number;
        y: number;
    };
}
/**
 * Creates a scales controller that centers the given mark in the frame, while
 * keeping the zoom scale the same.
 * @param mark The mark to center on
 * @param opts Options for the mark follower
 */
export declare function centerOn<AttributeSet extends MarkAttributes>(mark: Mark<AttributeSet>, opts?: {
    xAttr?: keyof AttributeSet;
    yAttr?: keyof AttributeSet;
    padding?: number;
    transformCoordinates?: boolean;
    inverseTransformCoordinates?: boolean;
}): MarkFollower<AttributeSet>;
/**
 * Creates a scales controller that keeps the given set of marks in frame.
 * @param marks The marks to place in the viewport
 * @param opts Options for the mark follower
 */
export declare function markBox<AttributeSet extends MarkAttributes>(marks: Mark<AttributeSet>[], opts?: {
    xAttr?: keyof AttributeSet;
    yAttr?: keyof AttributeSet;
    padding?: number;
    transformCoordinates?: boolean;
    inverseTransformCoordinates?: boolean;
}): MarkFollower<AttributeSet>;

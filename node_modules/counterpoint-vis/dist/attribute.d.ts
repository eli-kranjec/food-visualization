import { Animator } from './animator';
import { Advanceable } from './ticker';
export type AttributeListener<T, U, V> = (attribute: Attribute<T, U, V>, animated: boolean) => void;
export declare enum AttributeRecompute {
    DEFAULT = 0,
    ALWAYS = 1,
    WHEN_UPDATED = 2
}
/**
 * Options to create an `Attribute`.
 * @memberof Attribute
 */
export interface AttributeDefinition<TransformedValueType extends Exclude<any, Function>, ValueType = TransformedValueType, ComputeArgumentType = any> {
    /**
     * The value of the attribute, if it is not updated using a dynamic function.
     */
    value?: ValueType;
    /**
     * A function that takes the attribute's compute argument and returns the
     * attribute's value. This overrides a static `value` property value.
     */
    valueFn?: ((computeArg: ComputeArgumentType) => ValueType) | null;
    /**
     * A function that transforms the value of the attribute before being returned.
     */
    transform?: ((raw: ValueType, computeArg: ComputeArgumentType) => TransformedValueType) | null;
    /**
     * If true, specifies that the transformed value should be cached and reused
     * when the raw value does not change (suitable when the transform function is
     * fixed). If false, specifies that the transform should be rerun every time
     * the value is requested - suitable when the transform function's behavior
     * may change from frame to frame. When the value is cached, the transform can
     * be updated by calling `updateTransform()` on the attribute.
     */
    cacheTransform?: boolean;
    /**
     * An argument to be passed to the attribute's `valueFn`. If undefined,
     * the attribute itself is passed as the argument.
     */
    computeArg?: ComputeArgumentType | undefined;
    /**
     * Defines the behavior of the attribute's computation when specified using a
     * value function. The default value of `AttributeRecompute.DEFAULT` causes the
     * value function to be called every time `get()`, `compute()`, or `animate()`
     * is called. If set to `AttributeRecompute.ALWAYS`, the value function is
     * called every time the `advance()` method is called (i.e. every tick). If
     * set to `AttributeRecompute.WHEN_UPDATED`, it will only be called when `compute()`
     * or `animate()` is called.
     */
    recompute?: AttributeRecompute;
    /**
     * If set to true, animations will be run without affecting the result of
     * the `advance()` method. This assumes that you will be responsible for
     * running the animation by calling `getPreload()`.
     */
    preload?: boolean;
}
export type PreloadAttributeValue<T> = {
    start: T;
    end: T;
    startTime: number;
    endTime: number;
};
type AttributeCopySpec<TransformedValueType extends Exclude<any, Function>, ValueType, ComputeArgumentType> = {
    [K in keyof AttributeDefinition<TransformedValueType, ValueType, ComputeArgumentType>]?: AttributeDefinition<TransformedValueType, ValueType, ComputeArgumentType>[K];
};
/**
 * An `Attribute` contains a value representing some aspect of state in a data
 * mark.
 */
export declare class Attribute<TransformedValueType, ValueType = TransformedValueType, ComputeArgumentType = any> implements AttributeDefinition<TransformedValueType, ValueType, ComputeArgumentType>, Advanceable {
    value: ValueType;
    valueFn: ((computeArg: ComputeArgumentType) => ValueType) | undefined;
    transform: ((raw: ValueType, computeArg: ComputeArgumentType) => TransformedValueType) | undefined;
    cacheTransform: boolean;
    private _cachedValue;
    computeArg: ComputeArgumentType | undefined;
    recompute: AttributeRecompute;
    private needsUpdate;
    private animation;
    label: any;
    private _computedValue;
    private _lastTickValue;
    private _animatedValue;
    private _hasComputed;
    private _timeProvider;
    private currentTime;
    private _changedLastTick;
    private _preload;
    private _listeners;
    private _animationCompleteCallbacks;
    private _animationCompleteTimeout;
    /**
     *
     * @param info Arguments describing how to populate the attribute, or a single
     *    value that should be stored as the `value` or `valueFn` of the attribute.
     */
    constructor(info: TransformedValueType | ((computeArg: ComputeArgumentType) => ValueType) | AttributeDefinition<TransformedValueType, ValueType, ComputeArgumentType>);
    /**
     * Registers this attribute as preloadable.
     */
    registerPreloadable(): Attribute<TransformedValueType, ValueType, ComputeArgumentType>;
    /**
     * Creates a new Attribute with identical options and values except for the
     * parameters specified in the given options object.
     *
     * @param newOptions An object containing options to apply to the new attribute
     * @returns the new copied attribute
     */
    copy(newOptions?: AttributeCopySpec<TransformedValueType, ValueType, ComputeArgumentType>): Attribute<TransformedValueType, ValueType, ComputeArgumentType>;
    addListener(listener: AttributeListener<TransformedValueType, ValueType, ComputeArgumentType>): void;
    removeListener(listener: AttributeListener<TransformedValueType, ValueType, ComputeArgumentType>): void;
    setTimeProvider(timeProvider: any): void;
    _getComputeArg(): ComputeArgumentType;
    /**
     * Synchronously computes the value of the attribute.
     */
    compute(): void;
    advance(dt?: number | undefined): boolean;
    _computeAnimation(recomputeOnComplete?: boolean): void;
    _animationFinished(): boolean;
    _performTransform(value: ValueType): TransformedValueType;
    _cleanUpAnimation(canceled?: boolean): void;
    /**
     * Retrieves the current (transformed) value. If a context is not provided,
     * the value returned will be the final value of any active transitions being
     * rendered.
     */
    get(): TransformedValueType;
    /**
     * Retrieves the current un-transformed value.
     */
    getUntransformed(): ValueType;
    /**
     * Returns an object that tells a renderer how to animate this attribute,
     * including four properties: `start` and `end` (the initial and final values of
     * the attribute) and `startTime` and `endTime` (the timestamps for the start and
     * end of the animation, in ms). If there is no animation, `startTime` and
     * `endTime` will be equal.
     *
     * @param currentTime A timestamp. If provided, the `startTime` and `endTime`
     *  values will be converted (assuming that the stored animation is computed
     *  with respect to the attribute's internal time representation).
     * @returns A preloadable animation for the attribute, where the `start` and
     *  `end` values are expressed as transformed values.
     */
    getPreload(currentTime?: number | null): PreloadAttributeValue<TransformedValueType>;
    /**
     * Returns an object that tells a renderer how to animate this attribute,
     * including four properties: `start` and `end` (the initial and final values of
     * the attribute) and `startTime` and `endTime` (the timestamps for the start and
     * end of the animation, in ms). If there is no animation, `startTime` and
     * `endTime` will be equal.
     *
     * @param currentTime A timestamp. If provided, the `startTime` and `endTime`
     *  values will be converted (assuming that the stored animation is computed
     *  with respect to the attribute's internal time representation).
     * @returns A preloadable animation for the attribute, where the `start` and
     *  `end` values are expressed as un-transformed values.
     */
    getPreloadUntransformed(currentTime?: number | null): PreloadAttributeValue<ValueType>;
    /**
     * Synchronously sets the value of the attribute and marks that it needs to
     * be updated on the next call to `advance()`.
     *
     * @param newValue The new value or value function.
     */
    set(newValue: ValueType | ((computeArg: ComputeArgumentType) => ValueType)): void;
    /**
     * Retrieves the non-animated value for the attribute, i.e. the final value
     * if an animation is in progress or the current value otherwise. This method
     * computes the value if specified as a value function.
     */
    data(): ValueType;
    /**
     * Returns the last value known for this attribute _without_ running the value
     * function.
     */
    last(): ValueType;
    /**
     * Returns the value that this attribute is approaching if animating (or `null`
     * if not available), or the current value if not animating. This method does
     * _not_ compute a new value for the attribute.
     */
    future(): ValueType;
    /**
     * Marks that the transform has changed for this attribute. Only applies when
     * `cached` is set to true.
     */
    updateTransform(): void;
    /**
     * @returns Whether or not the attribute is currently being animated
     */
    animating(): boolean;
    /**
     * Applies an animation to this attribute. The attribute will call the
     * `evaluate` method on the animation every time the attribute's `advance()`
     * method runs, until the time delta since the start of the animation exceeds
     * the duration of the animation.
     * @param animation an animation to run
     * @param context the context in which the animation runs
     */
    animate(animation: Animator<ValueType>): Attribute<TransformedValueType, ValueType, ComputeArgumentType>;
    /**
     * Wait until the attribute's current animation has finished.
     *
     * @param rejectOnCancel Whether or not to throw a promise rejection if the
     *  animation is canceled. The default is true.
     * @returns A `Promise` that resolves when the animation has completed, and
     *  rejects if the animation is canceled or superseded by a different animation.
     *  If `rejectOnCancel` is set to `false`, the promise resolves in both
     *  situations. If there is no active animation, the promise resolves immediately.
     */
    wait(rejectOnCancel?: boolean): Promise<Attribute<TransformedValueType, ValueType, ComputeArgumentType>>;
    /**
     * "Freezes" this attribute by setting it to its last value. This removes any
     * value functions and animations and replaces them with static values. The
     * value function will not be re-run.
     */
    freeze(): Attribute<TransformedValueType, ValueType, ComputeArgumentType>;
    /**
     * Sets transform of an attribute to a new function, can be applied to an Attribute,
     * a Mark, or a MarkRenderGroup
     * @param attrToModify attribute to modify
     * @param newFunc new function to set transform to
     */
    setTransform(newFunc: (raw: ValueType, computeArg: ComputeArgumentType) => TransformedValueType): void;
    /**
     * @returns whether or not this attribute changed value (due to animation or
     * other updates) on the last call to `advance`
     */
    changed(): boolean;
}
export {};

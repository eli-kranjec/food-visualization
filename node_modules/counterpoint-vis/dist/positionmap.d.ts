import { Mark } from './mark';
import { MarkRenderGroup } from './rendergroup';
type MarkCollectionType = MarkRenderGroup<any> | Mark<any> | Mark<any>[] | (() => Mark<any>) | (() => Mark<any>[]);
export type PositionMapOptions = {
    /** The names of the attributes to use for coordinates from each mark */
    coordinateAttributes?: string[];
    /**
     * The approximate average number of marks to place in each bin. This is used
     * to determine the bin size. If the number of marks will be very large, it is
     * recommended to set this to a higher number to prevent a very sparse hash map.
     */
    marksPerBin?: number;
    /**
     * Whether or not to run the transform function on each coordinate. If set to
     * `false`, this can allow the position map to run in untransformed coordinates
     * and thus be invariant to pan and zoom interactions, if the transform
     * function performs pan/zoom scaling.
     */
    transformCoordinates?: boolean;
    /**
     * The default maximum distance to search when hit-testing. Set this to the
     * largest distance from mark coordinates that would be expected to result in
     * a match.
     */
    maximumHitTestDistance?: number;
};
/**
 * A class that manages a hash table of positioned marks. After adding a
 * collection of marks from either render group(s) or other mark sets, you can
 * query the interaction map for the marks within a radius of a given point.
 * In order for the interaction map to produce correct results, you must call
 * the `invalidate` function when the mark set changes, such as by adding it as
 * an `onChange` listener to a `Ticker` instance.
 */
export declare class PositionMap {
    private markCollections;
    private _coordinateAttributes;
    private _positionMap;
    private _binSizes;
    private _extents;
    private _numBins;
    private _numMarks;
    private _transformCoordinates;
    private _maximumHitTestDistance;
    private _avgMarksPerBin;
    constructor(opts?: PositionMapOptions);
    /**
     * Adds a mark collection to the position map so that the coordinates of the
     * marks it contains will be tracked, and its marks can be returned by
     * `{@link marksNear}`.
     *
     * @param markCollection A collection of marks, such as a render group, a
     *  single mark, an array of marks, or a function returning a mark or array of
     *  marks.
     * @returns this `PositionMap` instance
     */
    add(markCollection: MarkCollectionType): PositionMap;
    /**
     * Removes a mark collection from the position map.
     *
     * @param markCollection The collection to remove (must be identical by ===
     *  to the mark collection that was originally added)
     * @returns This `PositionMap` instance
     */
    remove(markCollection: MarkCollectionType): PositionMap;
    /**
     * Notifies the position map that positions have changed and the mark positions
     * need to be recalculated. This does not recalculate the positions immediately.
     *
     * @returns this `PositionMap` instance
     */
    invalidate(): PositionMap;
    /**
     * Retrieves the mark positions and produces the internal representation to
     * calculate distances. This method should most likely not be called by user
     * code, as it will automatically be called when `marksNear` is called.
     *
     * @returns this `PositionMap` instance
     */
    compute(): PositionMap;
    _forEachMark(cb: (mark: Mark<any>) => void): void;
    _getPositionID(coords: number[]): number;
    /**
     * Retrieves all marks that are within the given distance of the given set of
     * coordinates.
     *
     * @param location The coordinates of a point to search by.
     * @param distance The maximum Euclidean distance allowed for points to be
     *  included in the results.
     * @param exact If `false`, return a list of candidates that is guaranteed to
     *  include all points within `distance` of `location`, but may include some
     *  false positives.
     *
     * @returns a list of marks whose coordinates are within `distance` of `location`,
     *  as well as potentially some false positives if `exact` is set to `false`.
     *  If `exact` is `true`, the returned array is sorted by Euclidean distance.
     */
    marksNear(location: number[], distance: number, exact?: boolean): Mark<any>[];
    _recursiveBinWalk(location: number[], distance: number, coordSubset?: number[], options?: {
        outerOnly?: boolean;
        distanceInBins?: boolean;
    }): Mark<any>[];
    /**
     * Performs a hit-test near the given coordinates and returns the first mark
     * that returns true according to the mark's `hitTest` function.
     *
     * @param location the coordinates to perform a hit-test near
     * @param maximumDistance the maximum distance to search within before stopping
     *
     * @returns the first Mark whose hit-test returns true for the given location,
     *  or null if none do.
     */
    hitTest(location: number[], maximumDistance?: number | null): Mark<any> | null;
    /**
     * Performs a hit-test at the given location and dispatches an event to the mark
     * closest to it, if it exists.
     *
     * @param location the location at which to fire the event
     * @param eventName the event type to dispatch
     * @param details an optional object representing information about the event
     * @returns the mark that received the event, or null if no mark was found
     */
    dispatchAt(location: number[], eventName: string, details?: any | undefined): Mark<any> | null;
}
export {};

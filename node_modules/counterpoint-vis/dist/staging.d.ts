import { AttributeSetBase, Mark } from './mark';
import { Advanceable } from './ticker';
export type StageManagerCallback<MarkType> = {
    /**
     * Initialize an element for an entry animation. This method should not be
     * asynchronous.
     *
     * @param element The element to initialize.
     */
    initialize?(element: MarkType): void;
    /**
     * Modify an element after it has been added to the render group so that it
     * is visible (e.g. by animating the alpha).
     *
     * @param element The element to show
     *
     * @returns a Promise that resolves when the animation would be completed.
     *  If no animation is performed, the method can simply be declared `async`
     *  and return as normal.
     */
    enter?(element: MarkType): Promise<void> | void;
    /**
     * Modify an element after it has been added to the render group so that it
     * is invisible (e.g. by animating the alpha).
     *
     * @param element The element to show
     *
     * @returns a Promise that resolves when the animation would be completed.
     *  If no animation is performed, the method can simply be declared `async`
     *  and return as normal.
     */
    exit?(element: MarkType): Promise<void> | void;
};
/**
 * Describes the state of a mark as it transitions from being added to the
 * render group and removed from it.
 */
export declare enum StagingState {
    Waiting = "waiting",
    Entering = "entering",
    Visible = "visible",
    Exiting = "exiting",
    Completed = "completed"
}
/**
 * Describes actions that should be performed on a mark.
 */
export declare enum StagingAction {
    Show = "show",
    Hide = "hide"
}
/**
 * A class that coordinates the entry and exit of marks. The stage manager handles
 * the complexity of adding marks to the canvas and removing them at the right
 * time, allowing you to simply call the `{@link show}` or `{@link hide}` method
 * to specify when an element should be rendered. Additionally, show and hide
 * calls can be configured to execute on the next run loop using the {@link defer}
 * property, so a call to `show` can be canceled by an equivalent call to `hide`.
 */
export declare class StageManager<AttributeSet extends AttributeSetBase> implements Advanceable {
    private _callbacks;
    private markStates;
    private marksByID;
    private queuedAnimations;
    private _flushTimer;
    animatingMarks: Set<Mark<AttributeSet>>;
    private _updated;
    /**
     * Whether or not to defer changes in presence/absence of marks to the
     * next frame. The default is `false`.
     */
    defer: boolean;
    private _showedPromiseWarning;
    /**
     * Whether or not to save marks that have been removed. This may cause high
     * memory usage if marks are frequently added and removed.
     */
    saveExitedMarks: boolean;
    constructor(callbacks?: StageManagerCallback<Mark<AttributeSet>>);
    /**
     * Tells the stage manager that the given set of marks is already visible.
     *
     * @param marks The marks that are already visible
     *
     * @returns This stage manager object
     */
    setVisibleMarks(marks: Mark<AttributeSet>[]): StageManager<AttributeSet>;
    /**
     * Sets options on the stage manager.
     *
     * @param opts Options to configure. Currently the only option supported is
     *  `{@link defer}`.
     * @returns This stage manager object with the options updated
     */
    configure(opts?: {
        defer?: boolean;
        saveExitedMarks?: boolean;
    }): StageManager<AttributeSet>;
    onInitialize(cb: StageManagerCallback<Mark<AttributeSet>>['initialize']): void;
    onEnter(cb: StageManagerCallback<Mark<AttributeSet>>['enter']): void;
    onExit(cb: StageManagerCallback<Mark<AttributeSet>>['exit']): void;
    advance(dt: number): boolean;
    /**
     * Performs the action for the mark with the given ID, and calls the
     * appropriate callbacks.
     */
    _perform(element: Mark<AttributeSet>, action: StagingAction): void;
    /**
     * Adds the given action to the queue if `{@link defer}` is `true`, otherwise
     * performs the action immediately.
     *
     * @returns `true` if the action was performed or queued successfully, or
     *  `false` if the current state of the mark indicated that a similar action
     *  has already been queued.
     */
    _enqueue(element: Mark<AttributeSet>, action: StagingAction): boolean;
    /**
     * Performs all actions that have been queued and clears the queue.
     */
    _flush(): void;
    /**
     * Attempts to show a given mark.
     *
     * @param id The ID of the mark to show, which should contain sufficient
     *    information to uniquely describe the mark.
     * @returns `true` if the mark was not visible and will be made visible, or
     *    `false` otherwise.
     */
    show(element: Mark<AttributeSet>): boolean;
    /**
     * Attempts to hide a mark with the given ID.
     *
     * @param id The ID of the mark to hide.
     * @returns `true` if the mark was visible and will be made invisible and
     *    subsequently destroyed, or `false` otherwise.
     */
    hide(element: Mark<AttributeSet>): boolean;
    /**
     * Returns the Mark with the given ID if it exists (in any state, including
     * exiting), or undefined if none exists.
     *
     * @param id The ID to lookup
     * @param visibleOnly If true, only return marks that are visible or scheduled
     *  to be visible. Otherwise, return any mark in the pool (including exiting).
     * @returns the mark with the given ID or undefined
     */
    get(id: any, visibleOnly?: boolean): Mark<AttributeSet> | undefined;
    forEach(callbackfn: (value: Mark<AttributeSet>, index: number) => void | any): void;
    /**
     * Returns all marks that this stage manager knows about.
     */
    getMarks(): Mark<AttributeSet>[];
    /**
     * Returns the number of marks that are entering, visible, or exiting.
     */
    count(): number;
    /**
     * Returns all marks that are either entering, visible, or exiting.
     */
    getVisibleMarks(): Mark<AttributeSet>[];
}

/**
 * Represents any object that can maintain an internal clock and run functions
 * after a time delta.
 */
export interface Advanceable {
    advance(dt: number | undefined): boolean;
}
/**
 * A wrapper for `requestAnimationFrame` that runs every frame. The callback
 * is only called when the `{@link Advanceable.advance()}` function returns
 * `true` or when the ticker is started, signifying that an update is needed.
 */
export declare class Ticker {
    private toAdvance;
    private _callbacks;
    private _lastTick;
    stopped: boolean;
    constructor(toAdvance: Advanceable | Advanceable[]);
    onChange(cb: () => void): Ticker;
    start(): Ticker;
    stop(): Ticker;
    tick(t: number): void;
}
/**
 * A ticker that _only_ requests frames when an animation is in progress. In
 * other words, the ticker stops when the `{@link Advanceable.advance()}`
 * function returns `false`. You must restart it when an animation has been
 * started by calling `{@link start}`. The callback is only called when the
 * `{@link Advanceable.advance()}` function returns `true` or when the ticker is
 * started, signifying that an update is needed.
 */
export declare class LazyTicker {
    private toAdvance;
    private _callbacks;
    private _lastTick;
    stopped: boolean;
    constructor(toAdvance: Advanceable | Advanceable[]);
    onChange(cb: () => void): LazyTicker;
    start(): LazyTicker;
    stop(): LazyTicker;
    tick(t: number): void;
}

import { AnimationOptions, AttributeSetBase, Mark, MarkAttributes, SimpleAnimationOptions, MarkUpdateListener, MarkEventListener, MarkHitTest } from './mark';
import { TimeProvider } from './utils';
import { AnimationCurve } from './animator';
import { Advanceable } from './ticker';
import { StageManager, StageManagerCallback } from './staging';
type RenderGroupOptions<T extends AttributeSetBase> = {
    timeProvider?: TimeProvider;
    lazyUpdates?: boolean;
    useStaging?: boolean;
    animationDuration?: number;
    animationCurve?: AnimationCurve;
    hitTest?: MarkHitTest<T>;
};
type GroupOptions<T, AttributeSet extends AttributeSetBase> = {
    [P in keyof T]: T[P] | ((mark: Mark<AttributeSet>, i: number) => T[P]);
};
export type GroupSimpleAnimationOptions<AttributeSet extends AttributeSetBase> = GroupOptions<SimpleAnimationOptions, AttributeSet>;
export type GroupAnimationOptions<AttributeSet extends AttributeSetBase, ValueType> = GroupOptions<AnimationOptions<ValueType>, AttributeSet>;
/**
 * Keeps track of a set of marks. This is helpful to track which
 * marks are being animated, thereby saving on computation in each
 * run loop.
 */
export declare class MarkRenderGroup<AttributeSet extends AttributeSetBase = MarkAttributes> implements Advanceable {
    private timeProvider;
    /**
     * The set of marks that this group contains. All marks have the same set
     * of attributes.
     */
    private marks;
    /**
     * A function that generates a mark given an ID, if provided at instantiation.
     */
    private factory;
    /**
     * Controls whether the mark group iterates over the entire set of marks in
     * every call to `advance()`. If set to `true`, only the marks that have
     * been explicitly changed through a call to `set...` or `animate...` will
     * be advanced. The default is `true`, and in most cases should not affect
     * behavior (unless an animation is being applied that the render group does
     * not know about).
     *
     * @note Even if lazy updates are turned on, computed mark attributes will
     * still reflect updated values when their value functions change. This means
     * that if a drawing loop always iterates over all marks, they will all be
     * updated even if only a subset has `advance` called.
     */
    lazyUpdates: boolean;
    /**
     * If `true`, use a stage manager to coordinate the entrance and exit of
     * marks.
     */
    useStaging: boolean;
    stage: StageManager<AttributeSet> | null;
    private marksByID;
    private markSet;
    private markArrayDirty;
    private animatingMarks;
    private updatedMarks;
    private preloadableProperties;
    private _forceUpdate;
    private _markListChanged;
    private _changedLastTick;
    private _defaultDuration;
    private _defaultCurve;
    private _hitTest;
    private _updateListeners;
    private _eventListeners;
    /**
     * @param marks The set of marks that this group should manage, all including
     *  the same set of attributes.
     * @param opts Options for the mark group (see {@link configure})
     */
    constructor(marks?: Mark<AttributeSet>[] | ((id: any) => Mark<AttributeSet>), opts?: RenderGroupOptions<AttributeSet>);
    /**
     * Applies configuration options to the render group.
     *
     * @param opts Options for the mark group, including:
     *  - `timeProvider`: a shared `TimeProvider` object to be used among all
     *    marks. By default a new time provider is created.
     *  - `lazyUpdates`: whether to iterate over only the updated marks in each
     *    iteration, or every mark. The default is `false`, meaning every mark
     *    is updated every iteration.
     *  - `animationDuration`: the default animation duration in milliseconds
     *    (default 1000)
     *  - `animationCurve`: the default animation curve to use (default ease-in-out)
     *  - `hitTest`: a function to run when the Mark's hitTest method is called,
     *    that takes the Mark and a coordinate array and returns true if the
     *    coordinates intersect with the mark.
     * @returns this render group
     */
    configure(opts: RenderGroupOptions<AttributeSet>): MarkRenderGroup<AttributeSet>;
    configureStaging(callbacks: StageManagerCallback<Mark<AttributeSet>>, opts?: {
        defer?: boolean;
        saveExitedMarks?: boolean;
    }): MarkRenderGroup<AttributeSet>;
    /**
     * Sets up the stage manager if it has not already been set up.
     */
    _setupStage(): void;
    /**
     * Sets up a mark for the first time.
     */
    _setupMark(m: Mark<AttributeSet>): void;
    /**
     * Configures a mark's default properties.
     * @param m the mark to configure
     */
    _configureMark(m: Mark<AttributeSet>): void;
    onUpdate<K extends keyof AttributeSet, AttributeType extends AttributeSet[K]>(attrName: K, action: MarkUpdateListener<AttributeSet, K, AttributeType>): MarkRenderGroup<AttributeSet>;
    onEvent(eventName: string, action: MarkEventListener<AttributeSet>): MarkRenderGroup<AttributeSet>;
    /**
     * Sends an event to the mark and runs its event listener if it has one.
     *
     * @param eventName The name of the event
     * @param details A details object to pass to the event listener
     * @returns a Promise if the event listener for this event name returns a Promise,
     *  otherwise nothing
     */
    dispatch(eventName: string, details?: any): Promise<void> | undefined;
    /**
     * Triggers the mark group to run an update even when no marks have been
     * explicitly updated. This only changes behavior when `lazyUpdates` is
     * set to `true`.
     *
     * @returns this render group
     *
     * @see lazyUpdates
     */
    forceUpdate(): MarkRenderGroup<AttributeSet>;
    /**
     * @returns The current time that all contained marks have
     */
    currentTime(): number;
    /**
     * @returns The set of marks that this render group knows about
     */
    getMarks(): Mark<AttributeSet>[];
    /**
     * Declares that the given attribute will only ever use preloadable animations.
     * Preloadable attributes will not be counted in calls to {@link marksAnimating}, and
     * only initial changes will be reflected in {@link marksChanged}. This permits
     * faster rendering by computing animations in shaders, and only computing
     * them on the CPU when explicitly requested through a call to {@link Attribute.get()}.
     *
     * @param attrName the attribute to register
     * @returns this render group
     */
    registerPreloadableProperty(attrName: keyof AttributeSet): MarkRenderGroup<AttributeSet>;
    /**
     * Advances all of the marks (or the updated marks, if `lazyUpdates` is set
     * to `true`) and returns whether a redraw is needed.
     *
     * @param dt The time elapsed since the last call to `advance`.
     *
     * @returns `true` if marks have changed and a redraw is needed, or `false`
     *  otherwise.
     */
    advance(dt: number): boolean;
    /**
     * @returns whether any marks are currently animating, excluding any marks that
     *  have a preloadable animation (since these are not regularly updated)
     */
    marksAnimating(): boolean;
    /**
     * Animates all marks to the value defined by the given function.
     *
     * @param attrName the attribute name to update
     * @param finalValueFn a function that takes a mark and its index, and returns
     *  a value or value function for that mark
     * @param options options for the animation, including the duration and curve
     *  to use
     * @returns this render group
     */
    animateTo<K extends keyof AttributeSet, AttributeType extends AttributeSet[K]>(attrName: K, finalValueFn: AttributeType['value'] | ((mark: Mark<AttributeSet>, i: number) => AttributeType['value'] | ((computeArg: AttributeType['computeArg']) => AttributeType['value'])), options?: GroupSimpleAnimationOptions<AttributeSet>): MarkRenderGroup<AttributeSet>;
    /**
     * Animates all marks to their new computed value, or uses a custom
     * interpolator.
     *
     * @param attrName the attribute name to update
     * @param options options for the animation, including the duration and curve
     *  to use. The `interpolator` option takes a function that allows you to
     *  specify a custom interpolator for each mark.
     * @returns this render group
     */
    animate<K extends keyof AttributeSet, ValueType extends AttributeSet[K]['value']>(attrName: K, options?: GroupAnimationOptions<AttributeSet, ValueType>): MarkRenderGroup<AttributeSet>;
    /**
     * Updates the value of the given attribute in every mark.
     *
     * @param attrName the attribute name to update
     * @param newValueFn an optional function that takes a mark and its index, and
     *  returns the new value or value function for that mark. If not provided,
     *  the attribute values will be recomputed using the existing value or value
     *  function.
     * @returns this render group
     */
    update<K extends keyof AttributeSet, AttributeType extends AttributeSet[K]>(attrName: K, newValueFn?: AttributeType['value'] | ((mark: Mark<AttributeSet>, i: number) => AttributeType['value'] | ((computeArg: AttributeType['computeArg']) => AttributeType['value'])) | undefined): MarkRenderGroup<AttributeSet>;
    /**
     * Waits for the animations on the specified attribute name(s) to complete.
     *
     * @param attrNames An attribute name or array of attribute names to wait for.
     * @param rejectOnCancel If true (default), reject the promise if any animation is
     *  canceled or superseded. If false, resolve the promise in this case.
     * @returns a `Promise` that resolves when all the animations for the given
     *  attributes have completed, and rejects if any of their animations are
     *  canceled or superseded by another animation (unless `rejectOnCancel` is set
     *  to `false`). If none of the listed attributes have an active animation,
     *  the promise resolves immediately.
     */
    wait<K extends keyof AttributeSet>(attrNames: K | K[], rejectOnCancel?: boolean): Promise<any>;
    /**
     * Retrieves the mark with the given ID, or undefined if it does not exist.
     * NOTE: Use of this method assumes there is only one mark ever added with the
     * given ID.
     *
     * @param id the ID of the mark to search for
     * @returns the `Mark` instance with the given ID or undefined
     */
    get(id: any): Mark<AttributeSet> | undefined;
    forEach(callbackfn: (value: Mark<AttributeSet>, index: number, array: Mark<AttributeSet>[]) => void | any): void;
    map<T>(mapper: (value: Mark<AttributeSet>, index: number, array: Mark<AttributeSet>[]) => T): T[];
    /**
     * Filters the marks so that a subsequent action can be performed.
     *
     * @example ```markSet.filter([...]).animateTo("alpha", 0.0)
     * @param filterer Predicate function
     * @returns a view of the render group with only a subset of the marks
     */
    filter(filterer: (value: Mark<AttributeSet>, index: number, array: Mark<AttributeSet>[]) => boolean): MarkRenderGroup<AttributeSet>;
    /**
     * Notifies every mark that the transform for the given attribute has changed.
     *
     * @param attrName the attribute whose transform has changed
     * @returns this render group
     *
     * @see Attribute.updateTransform
     */
    updateTransform(attrName: keyof AttributeSet): MarkRenderGroup<AttributeSet>;
    /**
     * Adds a mark to the render group.
     *
     * @param mark the mark to add
     * @returns this render group
     */
    addMark(mark: Mark<AttributeSet>): MarkRenderGroup<AttributeSet>;
    /**
     * Removes a mark from the render group.
     *
     * @param mark the mark to remove
     * @returns this render group
     */
    deleteMark(mark: Mark<AttributeSet>): MarkRenderGroup<AttributeSet>;
    /**
     * Adds a mark to the render group with the given ID. Use of this method
     * requires that the render group was instantiated with a factory function
     * instead of a static list.
     *
     * If the mark already exists, this method does nothing. If an existing mark
     * with the same ID is currently exiting the stage, that mark is reused.
     *
     * @param id the ID of the mark to create
     * @returns this render group
     */
    add(id: any): MarkRenderGroup<AttributeSet>;
    /**
     * Removes a mark with the given ID from the render group, or does nothing if
     * it does not exist.
     *
     * @param mark the mark to remove
     * @returns this render group
     */
    delete(id: any): MarkRenderGroup<AttributeSet>;
    /**
     * Returns true if the render group has the given mark (and it is visible if
     * using staging) or false otherwise.
     *
     * @param markID the mark ID to search for
     */
    has(markID: any): boolean;
    /**
     * @returns the number of marks in the render group
     */
    count(): number;
    /**
     * Sets transform of an attribute to a new function, can be applied to an Attribute,
     * a Mark, or a MarkRenderGroup
     * @param attrToModify attribute to modify
     * @param newFunc new function to set transform to
     */
    setTransform(attrToModify: string, newFunc: (raw: any, computeArg: any) => any): void;
    /**
     * @param attrNames the attributes to check for changes in (if none provided,
     *  checks all attributes)
     *
     * @returns whether or not any mark in the render group changed value (due to
     *  animation or other updates) on the last call to `advance`
     */
    changed<K extends keyof AttributeSet>(attrNames?: K | K[] | undefined): boolean;
}
export {};
